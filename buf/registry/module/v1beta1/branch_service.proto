// Copyright 2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package buf.registry.module.v1beta1;

import "buf/registry/module/v1beta1/branch.proto";
import "buf/registry/module/v1beta1/commit.proto";
import "buf/registry/module/v1beta1/module.proto";
import "buf/registry/module/v1beta1/resource.proto";
import "buf/validate/validate.proto";

option go_package = "buf.build/gen/go/bufbuild/registry/protocolbuffers/go/buf/registry/module/v1beta1";

// Operate on Branches.
service BranchService {
  // Get Branches by ID or name.
  rpc GetBranches(GetBranchesRequest) returns (GetBranchesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Get release Branches for specific Modules.
  rpc GetReleaseBranches(GetReleaseBranchesRequest) returns (GetReleaseBranchesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // List Branches for a given Module, Commit, Tag, or VCSCommit.
  rpc ListBranches(ListBranchesRequest) returns (ListBranchesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Append existing Commits onto Branches.
  //
  // This operation is atomic. Either all Commits are appended to the referenced Branches in the order
  // provided or an error is returned.
  //
  // This operation does not allow the caller to assert the state of Branches before appending any
  // Commits onto them. As a result, multiple concurrent AppendCommits operations that target the same
  // Branch will all succeed, and the latest Commit on the Branch will be determined by the last
  // request that succeeded. To deterministically append Commits onto a Branch, use
  // PatchBranchHistories instead.
  //
  // As opposed to most endpoints in the registry API, the returned response Values may not be
  // the same length as the input request Values. The returned response Values will include
  // the unique set of Branches that were updated as part of this request. If there were
  // multiple Commits appended to a single Branch, the length returned response Values will
  // be less than the length of the input request Values.
  rpc AppendCommits(AppendCommitsRequest) returns (AppendCommitsResponse);
  // Patch histories for Branches.
  //
  // This operation is atomic. Either all Branches have their histories patched or an error is
  // returned. Additionally, each patch in the request asserts the expected state of the branch. If
  // the actual state does not match the expected state, the patch is rejected and an error is
  // returned.
  rpc PatchBranchHistories(PatchBranchHistoriesRequest) returns (PatchBranchHistoriesResponse);
}

message GetBranchesRequest {
  // The Branches to request.
  repeated BranchRef branch_refs = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetBranchesResponse {
  // The retreived Branches in the same order as requested.
  repeated Branch branches = 1 [(buf.validate.field).repeated.min_items = 1];
}

message GetReleaseBranchesRequest {
  // The Modules to request the release Branches for.
  repeated ModuleRef module_refs = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetReleaseBranchesResponse {
  // The retrieved release Branches in the same order as requested.
  repeated Branch branches = 1 [(buf.validate.field).repeated.min_items = 1];
}

message ListBranchesRequest {
  // The maximum number of items to return.
  //
  // The default value is 10.
  uint32 page_size = 1 [(buf.validate.field).uint32.lte = 250];
  // The page to start from.
  //
  // If empty, the first page is returned,
  string page_token = 2 [(buf.validate.field).string.max_len = 4096];
  // The reference to list Branches for.
  //
  // See the documentation on Ref for resource resolution details.
  //
  // Once the resource is resolved, the following Branches are listed:
  //   - If a Module is referenced, all Branches for the Module are returned.
  //   - If a Commit is referenced, all Branches that contain the Commit are returned.
  //   - If a Tag is referenced, all Branches that contain the Tag are returned.
  //   - If a VCSCommit is referenced, all Branches that contain the VCSCommit are returned.
  //   - Is a Branch is referenced, this Branch is returned.
  //   - If a Digest is referenced, all Branches that contain a Commit with this Digest are returned.
  ResourceRef resource_ref = 3 [(buf.validate.field).required = true];
  // Whether to sort the Branches in descending order.
  bool sort_desc = 4;
}

message ListBranchesResponse {
  // The next page token.
  //
  /// If empty, there are no more pages.
  string next_page_token = 1 [(buf.validate.field).string.max_len = 4096];
  // The listed Branches.
  repeated Branch branches = 2;
}

message AppendCommitsRequest {
  message Value {
    // The Branch to append the Commit to.
    //
    // TODO: Does this branch need to already exist? If not, document, and perhaps
    // re-evaluate naming of RPC, or (more likely) just document that non-existent
    // branches will be created.
    BranchRef branch_ref = 1 [(buf.validate.field).required = true];
    // The ID of the Commit to push to the Branch.
    //
    // This Commit will become the latest Commit on the Branch.
    //
    // If the Commit already exists on the Branch, an error is returned.
    string commit_id = 2 [
      (buf.validate.field).required = true,
      (buf.validate.field).string.uuid = true
    ];
  }
  // The Commits to append with the Branches they should be appended to.
  //
  // Commits will be appended to a given Branch in the order they are provided. That is
  // [ Value<branch1,commit_id2>, Value<branch2,commit_id1>, Value<branch1, commit_id1> ]
  // will result in branch1 having commit_id2 appended first, commit_id1 appended last,
  // and branch2 having only commit_id1 appended.
  repeated Value values = 1 [(buf.validate.field).repeated.min_items = 1];
}

message AppendCommitsResponse {
  message Value {
    // The updated Branch to which a Commit was appended.
    Branch branch = 1 [(buf.validate.field).required = true];
  }
  // The Branches that were appended to. This list will be the unique set of Branches
  // that were appended to, and the length of values will be less than the length
  // of the input request values if multiple Commits were appended to a single Branch.
  // However, the response values will have Branches ordered in the same order that
  // the Branches first appeared in the request.
  repeated Value values = 1 [(buf.validate.field).repeated.min_items = 1];
}

message PatchBranchHistoriesRequest {
  // A request to create a new Branch with the expected history.
  //
  // At the end of this request, the Branch's history looks like: [...imported, ...added].
  message CreateBranchHistory {
    // The module for which to create the Branch.
    ModuleRef module_ref = 1 [(buf.validate.field).required = true];
    // The name of the branch to create.
    string branch_name = 2 [
      (buf.validate.field).required = true,
      (buf.validate.field).string.max_len = 250
    ];
    // The ID of another Commit on another Branch from which to import Branch history. The history
    // of any Branch that contains this Commit will be imported into the newly created Branch, up to
    // and including this Commit.
    //
    // This is primarily designed for use in forking a Branch from an existing Branch instead of
    // providing the new Branch's entire history.
    optional string import_from_commit_id = 3 [(buf.validate.field).string.uuid = true];
    // The IDs of Commits to add to the Branch, ordered in order in which they should be added to
    // the Branch's history.
    //
    // If history is also being imported from another Branch (using import_from_commit_id), these
    // Commits will be added to the Branch's history after the imported history.
    repeated string commit_ids_to_add = 4 [(buf.validate.field).string.uuid = true];
  }

  // A request to update an existing Branch's history.
  //
  // At the end of this request, the Branch's history looks like: [..., latest_commit, ...added].
  message PatchBranchHistory {
    // The branch to update the history of.
    BranchRef branch_ref = 1 [(buf.validate.field).required = true];
    // The ID of the latest Commit on the Branch.
    //
    // If the ID provided does not match the ID of the latest Commit on the Branch, an error is
    // returned.
    string latest_commit_id = 2 [
      (buf.validate.field).required = true,
      (buf.validate.field).string.uuid = true
    ];
    // The IDs of Commits to remove from the Branch, ordered in order in which they appear in the
    // Branch's history.
    //
    // These commits must appear in order at the end of the Branch's history.
    repeated string commit_ids_to_remove = 3 [(buf.validate.field).string.uuid = true];
    // The IDs of Commits to add to the Branch, ordered in order in which they should be added to
    // the Branch's history.
    //
    // If any Commits are referenced in commit_ids_to_remove, those Commits are removed before
    // these Commits are added to the Branch.
    repeated string commit_ids_to_add = 4 [(buf.validate.field).string.uuid = true];
  }

  message Value {
    oneof request {
      // A request to create a new Branch with the expected history.
      CreateBranchHistory new_branch_op = 1;
      // A request to patch the history of a Branch.
      //
      // After this request is successful, the history of the Branch will be:
      // [..., head, <commits to add>].
      PatchBranchHistory existing_branch_op = 2;
    }
  }
  // The requests to update Branch histories.
  //
  // Branches will be created/updated in the order provided.
  repeated Value values = 1 [(buf.validate.field).repeated.min_items = 1];
}

message PatchBranchHistoriesResponse {
  message Value {
    // The Branch whose history was updated.
    Branch branch = 1 [(buf.validate.field).required = true];
    // The new Commits after the previous HEAD, in the order that the Commits appear in history.
    repeated Commit commits = 3;
  }
  // The Branches that were updated, in the order of the request.
  repeated Value values = 1 [(buf.validate.field).repeated.min_items = 1];
}
