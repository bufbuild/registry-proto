// Copyright 2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package buf.registry.module.v1beta1;

import "buf/registry/module/v1beta1/branch.proto";
import "buf/registry/module/v1beta1/module.proto";
import "buf/registry/module/v1beta1/resource.proto";
import "buf/validate/validate.proto";

option go_package = "buf.build/gen/go/bufbuild/registry/protocolbuffers/go/buf/registry/module/v1beta1";

// Operate on Branches.
service BranchService {
  // Get Branches by ID or name.
  rpc GetBranches(GetBranchesRequest) returns (GetBranchesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Get release Branches for specific Modules.
  rpc GetReleaseBranches(GetReleaseBranchesRequest) returns (GetReleaseBranchesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // List Branches for a given Module, Commit, Tag, or VCSCommit.
  rpc ListBranches(ListBranchesRequest) returns (ListBranchesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Push existing Commits onto Branches.
  //
  // This operation is atomic. Either all Commits are pushed to the referenced Branches in the order
  // provided or an error is returned.
  //
  // This operation does not allow the caller to assert the state of Branches before pushing any
  // Commits onto them. As a result, multiple concurrent PushCommits operations that target the same
  // Branch will all succeed, and the head Commit on the Branch will be determined by the last
  // request that succeeded. To deterministically push Commits onto a Branch, use Rebase instead.
  rpc Push(PushRequest) returns (PushResponse);
  // Rebase existing Commits onto Branches.
  //
  // This operation is atomic. Either all Branches are rebased as represented in the given Operations,
  // or an error is returned. Additionally, each update in the request asserts the expected head Commit
  // of the branch. If the actual head Commit does not match the expected head COmmit, all Operations
  // are rejected and an error is returned.
  rpc Rebase(RebaseRequest) returns (RebaseResponse);
}

message GetBranchesRequest {
  // The Branches to request.
  repeated BranchRef branch_refs = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetBranchesResponse {
  // The retreived Branches in the same order as requested.
  repeated Branch branches = 1 [(buf.validate.field).repeated.min_items = 1];
}

message GetReleaseBranchesRequest {
  // The Modules to request the release Branches for.
  repeated ModuleRef module_refs = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetReleaseBranchesResponse {
  // The retrieved release Branches in the same order as requested.
  repeated Branch branches = 1 [(buf.validate.field).repeated.min_items = 1];
}

message ListBranchesRequest {
  // The maximum number of items to return.
  //
  // The default value is 10.
  uint32 page_size = 1 [(buf.validate.field).uint32.lte = 250];
  // The page to start from.
  //
  // If empty, the first page is returned,
  string page_token = 2 [(buf.validate.field).string.max_len = 4096];
  // The reference to list Branches for.
  //
  // See the documentation on Ref for resource resolution details.
  //
  // Once the resource is resolved, the following Branches are listed:
  //   - If a Module is referenced, all Branches for the Module are returned.
  //   - If a Commit is referenced, all Branches that contain the Commit are returned.
  //   - If a Tag is referenced, all Branches that contain the Tag are returned.
  //   - If a VCSCommit is referenced, all Branches that contain the VCSCommit are returned.
  //   - Is a Branch is referenced, this Branch is returned.
  //   - If a Digest is referenced, all Branches that contain a Commit with this Digest are returned.
  ResourceRef resource_ref = 3 [(buf.validate.field).required = true];
  // Whether to sort the Branches in descending order.
  bool sort_desc = 4;
}

message ListBranchesResponse {
  // The next page token.
  //
  /// If empty, there are no more pages.
  string next_page_token = 1 [(buf.validate.field).string.max_len = 4096];
  // The listed Branches.
  repeated Branch branches = 2;
}

message PushRequest {
  message Value {
    // The Branch to push the Commits to.
    //
    // If this is a name reference, and the named Branch does not exist, it will
    // be created and the given Commits will be the first Commits on the Branch.
    BranchRef branch_ref = 1 [(buf.validate.field).required = true];
    // The ID of the Commits to push to the Branch, in the order they should be added.
    //
    // This Commit will become the head Commit on the Branch.
    //
    // If the Commit already exists on the Branch, an error is returned.
    repeated string commit_ids = 2 [
      (buf.validate.field).repeated.min_items = 1,
      (buf.validate.field).repeated.items = {
        string: {uuid: true}
      }
    ];
  }
  // The Commits to push with the Branches they should be pushed to.
  //
  // All Values should have unique BranchRefs, that is no two Values should have
  // a BranchRef that refers to the same Branch. An error will be returned if any
  // two BranchRefs refer to the same Branch.
  repeated Value values = 1 [(buf.validate.field).repeated.min_items = 1];
}

message PushResponse {
  // The Branches that were pushed to, in the order they appeared in the request.
  repeated Branch branches = 1 [(buf.validate.field).repeated.min_items = 1];
}

message RebaseRequest {
  // An operation to apply as part of the rebase.
  message Operation {
    // An operation to create a Branch.
    message CreateBranch {
      // The Module to create the Branch on.
      ModuleRef module_ref = 1 [(buf.validate.field).required = true];
      // The name of the Branch to create.
      //
      // If a Branch with this name already exists on the Module, this will result in an error.
      string branch_name = 2 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.max_len = 250
      ];
      // The ID of the Commit for which to start history from. The history of the branch will
      // reflect the history as if you called ListCommitHistory for this Commit ID.
      //
      // If this is empty, the created Branch will only have the Commits specified in
      // add_commit_ids.
      //
      // This is primarily designed for use in forking a Branch instead of
      // providing the new Branch's entire history.
      string start_commit_id = 3 [(buf.validate.field).string.uuid = true];
      // The IDs of the Commits to add to the Branch, in the order they should be added.
      //
      // If start_commit_id is specified, these will be appended to the Commit history
      // that aleady exists up to start_commit_id.
      //
      // If start_commit_id is not specified, the newly-created Branch will have exactly
      // these Commits, in this order.
      repeated string add_commit_ids = 4 [(buf.validate.field).repeated.items = {
        string: {uuid: true}
      }];
    }

    // An operation to update an existing branch.
    message UpdateBranch {
      // The branch to update.
      BranchRef branch_ref = 1 [(buf.validate.field).required = true];
      // The ID of the Commit that the caller expects to be the head Commit on the Branch.
      //
      // If this ID does not match the ID of the head Commit on the Branch, an error is
      // returned.
      string expected_head_commit_id = 2 [
        (buf.validate.field).required = true,
        (buf.validate.field).string.uuid = true
      ];
      // The IDs of the Commits to remove from the Branch.
      //
      // Commits are removed before any Commits are added from add_commit_ids.
      //
      // Note that it is valid to have one of the remove_commit_ids be equal to the
      // expected_head_commit_id. If this is the case, the Branch will have a different
      // head Commit that add_commit_ids will be applied to.
      repeated string remove_commit_ids = 3 [(buf.validate.field).repeated.items = {
        string: {uuid: true}
      }];
      // The IDs of the Commits to add to the Branch, in the order they should be added.
      //
      // These are added starting at the head Commit after remove_commit_ids has been applied.
      //
      // Note that is is valid to have IDs in both add_commit_ids and remove_commit_ids. If
      // this is the case, the IDs will be removed from the Branch prior to re-adding them after
      // the head Commit via add_commit_ids.
      repeated string add_commit_ids = 4 [(buf.validate.field).repeated.items = {
        string: {uuid: true}
      }];
    }

    oneof value {
      option (buf.validate.oneof).required = true;
      // Create a new branch.
      CreateBranch create_branch = 1;
      // Update an existing branch.
      UpdateBranch patch_branch = 2;
    }
  }

  // The operations to apply.
  //
  // The Operations will be applied in the order they are provided. Notably, this means that
  // if a CreateBranch Operation precedes a UpdateBranch Operation for the same Branch, the
  // UpdateBranch Operation is applied to the newly-created Branch, including any new Commits
  // that were added from the CreateBranch Operation. Conversely, if a UpdateBranch Operation
  // precedes the CreateBranch operation that creates the Branch, this will result in an error.
  repeated Operation operations = 1 [(buf.validate.field).repeated.min_items = 1];
}

message RebaseResponse {
  // The Branches that were updated. This list will be the unique set of Branches
  // that were updated, and the length of values will be less than the length
  // of the input Operations if multiple Operations were applied for a single Branch.
  // However, the response Branches ordered in the same order that the Branches
  // first appeared in the request Operations.
  repeated Branch branches = 1 [(buf.validate.field).repeated.min_items = 1];
}
