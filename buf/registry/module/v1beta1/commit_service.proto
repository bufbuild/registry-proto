// Copyright 2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package buf.registry.module.v1beta1;

import "buf/registry/module/v1beta1/commit.proto";
import "buf/registry/module/v1beta1/module.proto";
import "buf/registry/module/v1beta1/resource.proto";
import "buf/registry/module/v1beta1/vcs_commit.proto";
import "buf/registry/storage/v1beta1/storage.proto";
import "buf/validate/validate.proto";

option go_package = "buf.build/gen/go/bufbuild/registry/protocolbuffers/go/buf/registry/module/v1beta1";

// Operate on Commits.
service CommitService {
  // Resolve commits by Commit ID, Module, Branch, Tag, or VCSCommit.
  rpc ResolveCommits(ResolveCommitsRequest) returns (ResolveCommitsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // List linear Commit history starting at a given Commit, Module, Branch, Tag, or VCSCommit.
  rpc ListCommitHistory(ListCommitHistoryRequest) returns (ListCommitHistoryResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Create commits on a Module with associated Content.
  //
  // These commits will not be associated with any Branch or Tag after the completion of
  // this operation. To associate created Commits, use BranchService.Push or BranchService.Rebase.
  //
  // This operation is atomic. Either all Commits and associated content are created or an error is returned.
  rpc CreateCommits(CreateCommitsRequest) returns (CreateCommitsResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  // Get the pointers to the content for a given set of Commits, Modules, Branches, Tags, or VCSCommits.
  //
  // Nodes consist of:
  //   - The FileNodes: .proto files, license files, and documentation files.
  //   - The dependencies.
  //
  // Retrieving file content is a multi-step process:
  //   - Get the FileNode messages via this RPC. FileNodes are a map from path to digest.
  //   - Get the Blob messages via GetBlobs. Blobs are a map from digest to content.
  //   - If file content for the dependencies is desired, Get the Commits for the DepNodes,
  //     and call GetCommitCodes for those dependencies.
  rpc GetCommitNodes(GetCommitNodesRequest) returns (GetCommitNodesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Get the Blobs for files within Commits for a given set of Digests.
  rpc GetBlobs(GetBlobsRequest) returns (GetBlobsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Get the digests for Blobs that are not currently stored on the server.
  rpc GetMissingBlobDigests(GetMissingBlobDigestsRequest) returns (GetMissingBlobDigestsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

message ResolveCommitsRequest {
  // References to request a Commit for.
  //
  // See the documentation on ResourceRef for resource resolution details.
  //
  // Once the resource is resolved, this reference is interpeted to refer to the following Commit:
  //   - If a Module is referenced, this is interpreted to mean the latest released Commit on the Module.
  //   - If a Commit is referenced, this just references that specific commit.
  //   - If a Tag is referenced, this is interpreted to mean the Commit associated with the Tag.
  //   - If a VCSCommit is referenced, this is interpreted to mean the Commit associated with the VCSCommit.
  //   - Is a Branch is referenced, this is interpreted to mean the head Commit on the Branch.
  //   - If a Digest is referenced, this is interpreted to mean the latest released Commit that has this Digest.
  //     Digests referencing unreleased Commits cannot be referenced.
  //
  // TODO: what is "latest released Commit" if we now have "head Commit"?
  repeated ResourceRef resource_refs = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message ResolveCommitsResponse {
  // The found Commits in the same order as requested.
  repeated Commit commits = 1 [(buf.validate.field).repeated.min_items = 1];
}

message ListCommitHistoryRequest {
  // The maximum number of items to return.
  //
  // The default value is 10.
  uint32 page_size = 1 [(buf.validate.field).uint32.lte = 250];
  // The page to start from.
  //
  // If empty, the first page is returned.
  string page_token = 2 [(buf.validate.field).string.max_len = 4096];
  // The reference to get the history for.
  //
  // See the documentation on ResourceRef for resource resolution details.
  //
  // Once the resource is resolved, history is started from the following Commit:
  //   - If a Module is referenced, history is started at the latest released Commit on the Module.
  //   - If a Commit is referenced, history is started at this Commit.
  //   - If a Tag is referenced, history is started at the Commit associated with the Tag.
  //   - If a VCSCommit is referenced, history is started at the Commit associated with the VCSCommit.
  //   - Is a Branch is referenced, history is started at the head Commit on the Branch.
  //   - If a Digest is referenced, history is started at the latest released Commit that has this Digest.
  //     Digests referencing unreleased Commits cannot be referenced.
  //
  // TODO: what is "latest released Commit" if we now have "head Commit"?
  ResourceRef resource_ref = 3 [(buf.validate.field).required = true];
  // Only return Commits that have one or more associated Tags.
  bool has_tag = 4;
  // Only return Commits that have one or more associated VCSCommits.
  bool has_vcs_commit = 5;
  // Whether to sory the Commits in descending order.
  bool sort_desc = 6;
}

message ListCommitHistoryResponse {
  // The next page token.
  //
  /// If empty, there are no more pages.
  string next_page_token = 1 [(buf.validate.field).string.max_len = 4096];
  // The listed Commits.
  repeated Commit commits = 2;
}

message CreateCommitsRequest {
  // Information on an associated VCS commit needed to create a VCSCommit.
  message AssociatedVCSCommit {
    // The hash of the VCSCommit.
    //
    // VCS-specific.
    // Unique within a given Module.
    string hash = 1 [
      (buf.validate.field).required = true,
      (buf.validate.field).string.pattern = "^[0-9a-fA-F]{40}$"
    ];
    // The type of VCS.
    VCSType type = 2 [
      (buf.validate.field).required = true,
      (buf.validate.field).enum.defined_only = true
    ];
    // The URL of of the repository on the VCS.
    string vcs_repository_url = 3 [(buf.validate.field).string.uri = true];
    // The name of the author of the VCSCommit.
    //
    // VCS-specific: not associated with the name of Users on the BSR, for example.
    string author_name = 4;
    // The email of the author of the VCSCommit.
    //
    // VCS-specific: not associated with the Users on the BSR, for example.
    string author_email = 5;
    // The name of the committer of the VCSCommit.
    //
    // VCS-specific: not associated with the name of Users on the BSR, for example.
    string committer_name = 6;
    // The email of the committer of the VCSCommit.
    //
    // VCS-specific: not associated with the Users on the BSR, for example.
    string committer_email = 7;
  }

  // A pointer to a dependency of a Module.
  message DepNode {
    // The reference to the Module to create a Commit for.
    ModuleRef module_ref = 1 [(buf.validate.field).required = true];
    // The digest of the dependency.
    buf.registry.storage.v1beta1.Digest digest = 2 [(buf.validate.field).required = true];
  }

  // The pointers to the content of a single Module that a Commit will be created for.
  message ModuleNode {
    // The reference to the Module to create a Commit for.
    ModuleRef module_ref = 1 [(buf.validate.field).required = true];
    // The FileNodes for the Module.
    //
    // This consists of the .proto files, license files, and documentation files. This does
    // not contain any files relating to dependencies or configuration (such as buf.lock or
    // buf.yaml). A server will respond with an error if an unexpected file is passed here.
    //
    // Blobs are shared across Modules within a given CreateCommit call; missing blobs
    // should be passed via the missing_blobs field. See GetMissingBlobDigests for more details.
    repeated buf.registry.storage.v1beta1.FileNode file_nodes = 2 [(buf.validate.field).repeated.min_items = 1];
    // The dependencies of the Module.
    repeated DepNode dep_nodes = 3;
  }

  message Value {
    // The pointers to the content for the Modules that should have Commits created for them.
    //
    // Each ModuleNode must have a unique ModuleRef.
    // A commit will be created for each ModuleNode.
    repeated ModuleNode module_nodes = 1 [(buf.validate.field).repeated.min_items = 1];
    // Associated VCS commit information.
    //
    // If there are already VCSCommits on the associated Module with a given hash, this
    // will result in an error. Otherwise, a new VCSCommit is created.
    repeated AssociatedVCSCommit associated_vcs_commits = 2;
  }
  // The requests to create Commits.
  repeated Value values = 1 [(buf.validate.field).repeated.min_items = 1];
  // Blobs for the FileNodes referenced by file_nodes that are not present on the server.
  //
  // Only Blobs that were returned as missing from GetMissingBlobDigests need to be sent.
  // Other Blobs already exist on the server, and will be ignored.
  //
  // If a FileNode has a Blob that is not on the server, and is not
  // within missing_blobs, an error will be returned.
  repeated buf.registry.storage.v1beta1.Blob missing_blobs = 2;
}

message CreateCommitsResponse {
  // The created Commits, in the order of the nodes given via module_nodes.
  //
  // If the digest was found for an pre-existing Commit, this pre-existing Commit will be returned
  // instead of a new Commit being created.
  repeated Commit commits = 1 [(buf.validate.field).repeated.min_items = 1];
}

message GetCommitNodesRequest {
  // An individual request for pointers to the content of a single Commit, Module, Branch, Tag, or VCSCommit.
  message Value {
    // The reference to get nodes for.
    //
    // See the documentation on ResourceRef for resource resolution details.
    //
    // Once the resource is resolved, files are returned from the following Commit:
    //   - If a Module is referenced, files are returned from the latest released Commit on the Module.
    //   - If a Commit is referenced, files are returned from this Commit.
    //   - If a Tag is referenced, files are returned from the Commit associated with the Tag.
    //   - If a VCSCommit is referenced, files are returned from the Commit associated with the VCSCommit.
    //   - Is a Branch is referenced, files are returned from the head Commit on the Branch.
    //   - If a Digest is referenced, files are returned from the latest released Commit that has this Digest.
    //     Digests referencing unreleased Commits cannot be referenced.
    //
    // TODO: what is "latest released Commit" if we now have "head Commit"?
    ResourceRef resource_ref = 1 [(buf.validate.field).required = true];
    // Specific file paths to retrieve.
    //
    // If empty, all file paths for the given reference are retrieved.
    //
    // The path must be relative, and connect contain any "." or ".." components
    // The separator "/" must be used.
    repeated string paths = 2 [(buf.validate.field).repeated.items = {
      string: {
        max_len: 4096
        not_contains: "\\"
        pattern: "^([^/.][^/]?|[^/][^/.]|[^/]{3,})(/([^/.][^/]?|[^/][^/.]|[^/]{3,}))*$"
      }
    }];
    // Whether to allow file paths not to exist within the given module.
    //
    // For example, one may want to retrieve the file paths "buf.md" and "README.md",
    // but only expect one to actually exist.
    //
    // If false, it is an error to specify non-existent file paths.
    bool allow_paths_not_exist = 3;
  }
  // The File sets to request.
  repeated Value values = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetCommitNodesResponse {
  // A single Commit node and its associated FileNodes and dependencies.
  message CommitNode {
    // The Commit for the nodes referenced in this message.
    //
    // The Digest on the Commit will always match the Digest calculable by the FileNodes and the DepNodes.
    Commit commit = 1 [(buf.validate.field).required = true];
    // The FileNodes for the files associated with this Commit.
    //
    // This will consist of the .proto files, license files, and documentation files.
    // Use GetBlobs to get the content of these files.
    repeated buf.registry.storage.v1beta1.FileNode file_nodes = 2 [(buf.validate.field).repeated.min_items = 1];
    // The Commits representing the dependencies of the Module at this commit.
    //
    // Use GetCommitNodes recursively to get the nodes for dependency commits.
    repeated Commit deps = 3;
  }
  // The returned CommitNodes in the same order as requested.
  repeated CommitNode commit_nodes = 1 [(buf.validate.field).repeated.min_items = 1];
}

message GetBlobsRequest {
  // A set of blog Digests associated with a Module.
  message Value {
    // The reference to the Module that the Blobs belong to.
    ModuleRef module_ref = 1 [(buf.validate.field).required = true];
    // The Digests to retrieve Blobs for.
    repeated buf.registry.storage.v1beta1.Digest blob_digests = 2 [
      (buf.validate.field).repeated.min_items = 1,
      (buf.validate.field).repeated.max_items = 250
    ];
  }
  repeated Value values = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetBlobsResponse {
  // A set of missing blob Digests associated with a Module.
  message Value {
    // The Module that associated with the Blobs.
    Module module = 1 [(buf.validate.field).required = true];
    // The retrieved Blobs.
    repeated buf.registry.storage.v1beta1.Blob blobs = 2 [
      (buf.validate.field).repeated.min_items = 1,
      (buf.validate.field).repeated.max_items = 250
    ];
  }
  repeated Value values = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetMissingBlobDigestsRequest {
  // A set of blob Digests associated with a Module.
  message Value {
    // The reference to the Module that the digests belong to.
    ModuleRef module_ref = 1 [(buf.validate.field).required = true];
    // The Digests to see if we have Blobs for.
    repeated buf.registry.storage.v1beta1.Digest blob_digests = 2 [
      (buf.validate.field).repeated.min_items = 1,
      (buf.validate.field).repeated.max_items = 250
    ];
  }
  repeated Value values = 1 [
    (buf.validate.field).repeated.min_items = 1,
    (buf.validate.field).repeated.max_items = 250
  ];
}

message GetMissingBlobDigestsResponse {
  // A set of missing blob Digests associated with a Module.
  message Value {
    // The Module that the missing digests are for.
    Module module = 1 [(buf.validate.field).required = true];
    // The digests that are missing.
    repeated buf.registry.storage.v1beta1.Digest missing_blob_digests = 2 [(buf.validate.field).repeated.min_items = 1];
  }
  // The digests that are missing.
  repeated Value values = 1;
}
